Where should the assembly language be ORG'd so that it can be as large
as possible and still run on any Model T without changes? 

Two copies must be stored: One in the filesystem and one for RUNM (or LOADM).

LOADM and RUNM put a copy starting at HIMEM. If it is too long and
exceeds MAXRAM, bad things will happen and you will *not* be warned.

After LOADM, the .CO file can be deleted to free up RAM, but machine
language programs are still limited to *half* the available RAM. 

The assembly program's ORG is HIMEM.
The binary file's length must be less than MAXRAM minus HIMEM.

HIMEM is set using the CLEAR command to reserve space for CO files.

HIMEM's address is the first byte reserved.
MAXRAM is the first byte UNreserved (NOT the last byte reserved).

Hackerb9 defines "MINRAM":

	The lowest address for HIMEM that can be set with CLEAR 0, x
	without getting "?OM Error". The absolute lowest will be with
	no files in the filesystem and MAXFILES=0. Machines with less
	memory have a larger MINRAM.

LARGEST MINRAM
8K Model 100: MINRAM is 57777,
	      when string space=0, MAXFILES=0, and there are no files.
		MAXFILES=0
		CLEAR 0, 57777

SMALLEST MAXRAM
Tandy 200:    MAXRAM is 61104


Thus... the largest cross-platform machine language file would be:

	(61104-57777)/2 = 1663.5 bytes

	[Give or take. the LOADM copy uses six less bytes and filesystem adds
	 a few more bytes in the header of the file.]

So, the ideal address for ORG (HIMEM) is approximately 59441 (E831).


======================================================================

Two reasons the CRC-16 .CO file is so large:

	* The bytewise algorithm is the default because it is fastest,
          but it does that by including a 256 byte precomputed table.

	* The strings for mapping the checksum to a Model T's make and
	  model get long very quickly and there are many of them due to
	  variants (Y2K, Virtual-T)

Possible solutions:

	1. Switch to the bitwise algorithm which is quite a bit
	   smaller and still tolerably fast.

	2. Keep the detailed information in a separate file.
	   NOT EASY! Each machine architecture has a different
	   location for calls to access files. 

	   A text file will not need to be duplicated into high memory
	   via LOADM. Does require file manipulation and parsing,
	   which could outweigh the space saving.
	   
	   Having multiple files is messy for distribution, things get
	   separated, but it does have the advantage that the program
	   could be quickly updated with new checksums. Perhaps a
	   hybrid approach could work? It'd have minimal functionality
	   standalone, but if a file exists, it uses it for additional
	   information. 

	3. Use the Quick ID PEEKs to print out the make and model and
           use the CRC to print the specific variation.

	  a. Easiest is to allow free form variant text as that's
             already working.
    [x]    DONE!

    	  b. Allow characters > 127 to be defined as keywords to
    	     replace. This would be done in mkcrctable.awk. 

	         C128:	DB "Virtual-T ", 0
	         C129:	DB "Y2K patched ", 0
		 CERR:  DB "Error in mkcrctable.awk", 0
		 HIGHASCIITABLE: DB 128
		 		 DW C128
				 DB 129
				 DW C129
				 DB 0
				 DW CERR

	     Then PRT0HA could be a modification to PRT0 that prints
	     ASCII normally, but high-ascii gets looked up in the
	     table and PRT0 called to print the string.

	  c. Alternately, since it'll be extremely repetitive, use a
	     16-bit field with each bit indicating a variant. (For
             example, a file might be modded for both Y2K and Virtual-T).

	     * If a bit field is used, optional freeform text may still
               be useful if we wish to show the Virtual T version number.
               (Each version has a different CRC).

